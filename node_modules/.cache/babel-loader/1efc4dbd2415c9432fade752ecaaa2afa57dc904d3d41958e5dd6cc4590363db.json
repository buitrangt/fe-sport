{"ast":null,"code":"// Date utilities for backend communication\nexport const formatDateForBackend = date => {\n  if (!date) return null;\n  try {\n    const dateObj = date instanceof Date ? date : new Date(date);\n\n    // Check if date is valid\n    if (isNaN(dateObj.getTime())) {\n      console.error('Invalid date for backend formatting:', date);\n      return null;\n    }\n\n    // Format as YYYY-MM-DDTHH:mm:ss (LocalDateTime format for Java backend)\n    const year = dateObj.getFullYear();\n    const month = String(dateObj.getMonth() + 1).padStart(2, '0');\n    const day = String(dateObj.getDate()).padStart(2, '0');\n    const hours = String(dateObj.getHours()).padStart(2, '0');\n    const minutes = String(dateObj.getMinutes()).padStart(2, '0');\n    const seconds = String(dateObj.getSeconds()).padStart(2, '0');\n    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;\n  } catch (error) {\n    console.error('Error formatting date for backend:', error, 'Date:', date);\n    return null;\n  }\n};\nexport const safeDateParse = dateString => {\n  if (!dateString) return null;\n  try {\n    // Handle different date string formats\n    let date;\n    if (typeof dateString === 'string') {\n      // Remove timezone info if present (Z suffix)\n      const cleanDateString = dateString.replace('Z', '');\n      date = new Date(cleanDateString);\n    } else {\n      date = new Date(dateString);\n    }\n\n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n      console.warn('Could not parse date:', dateString);\n      return null;\n    }\n    return date;\n  } catch (error) {\n    console.error('Error parsing date:', error, 'Input:', dateString);\n    return null;\n  }\n};\nexport const formatLocalDateTime = date => {\n  if (!date) return '';\n  try {\n    const dateObj = safeDateParse(date);\n    if (!dateObj) return '';\n\n    // Format for display: DD/MM/YYYY HH:mm\n    const day = String(dateObj.getDate()).padStart(2, '0');\n    const month = String(dateObj.getMonth() + 1).padStart(2, '0');\n    const year = dateObj.getFullYear();\n    const hours = String(dateObj.getHours()).padStart(2, '0');\n    const minutes = String(dateObj.getMinutes()).padStart(2, '0');\n    return `${day}/${month}/${year} ${hours}:${minutes}`;\n  } catch (error) {\n    console.error('Error formatting local date time:', error);\n    return '';\n  }\n};\nexport default {\n  formatDateForBackend,\n  safeDateParse,\n  formatLocalDateTime\n};","map":{"version":3,"names":["formatDateForBackend","date","dateObj","Date","isNaN","getTime","console","error","year","getFullYear","month","String","getMonth","padStart","day","getDate","hours","getHours","minutes","getMinutes","seconds","getSeconds","safeDateParse","dateString","cleanDateString","replace","warn","formatLocalDateTime"],"sources":["C:/Users/ACER/Desktop/fe/fe-edu/src/utils/dateUtils.js"],"sourcesContent":["// Date utilities for backend communication\nexport const formatDateForBackend = (date) => {\n  if (!date) return null;\n  \n  try {\n    const dateObj = date instanceof Date ? date : new Date(date);\n    \n    // Check if date is valid\n    if (isNaN(dateObj.getTime())) {\n      console.error('Invalid date for backend formatting:', date);\n      return null;\n    }\n    \n    // Format as YYYY-MM-DDTHH:mm:ss (LocalDateTime format for Java backend)\n    const year = dateObj.getFullYear();\n    const month = String(dateObj.getMonth() + 1).padStart(2, '0');\n    const day = String(dateObj.getDate()).padStart(2, '0');\n    const hours = String(dateObj.getHours()).padStart(2, '0');\n    const minutes = String(dateObj.getMinutes()).padStart(2, '0');\n    const seconds = String(dateObj.getSeconds()).padStart(2, '0');\n    \n    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;\n  } catch (error) {\n    console.error('Error formatting date for backend:', error, 'Date:', date);\n    return null;\n  }\n};\n\nexport const safeDateParse = (dateString) => {\n  if (!dateString) return null;\n  \n  try {\n    // Handle different date string formats\n    let date;\n    \n    if (typeof dateString === 'string') {\n      // Remove timezone info if present (Z suffix)\n      const cleanDateString = dateString.replace('Z', '');\n      date = new Date(cleanDateString);\n    } else {\n      date = new Date(dateString);\n    }\n    \n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n      console.warn('Could not parse date:', dateString);\n      return null;\n    }\n    \n    return date;\n  } catch (error) {\n    console.error('Error parsing date:', error, 'Input:', dateString);\n    return null;\n  }\n};\n\nexport const formatLocalDateTime = (date) => {\n  if (!date) return '';\n  \n  try {\n    const dateObj = safeDateParse(date);\n    if (!dateObj) return '';\n    \n    // Format for display: DD/MM/YYYY HH:mm\n    const day = String(dateObj.getDate()).padStart(2, '0');\n    const month = String(dateObj.getMonth() + 1).padStart(2, '0');\n    const year = dateObj.getFullYear();\n    const hours = String(dateObj.getHours()).padStart(2, '0');\n    const minutes = String(dateObj.getMinutes()).padStart(2, '0');\n    \n    return `${day}/${month}/${year} ${hours}:${minutes}`;\n  } catch (error) {\n    console.error('Error formatting local date time:', error);\n    return '';\n  }\n};\n\nexport default {\n  formatDateForBackend,\n  safeDateParse,\n  formatLocalDateTime\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}